/*solution 1
 * 每次取出一个二进制位，判断他是否为1。循环32次结束
 */
class Solution {
public:
    int hammingWeight(uint32_t n) {
        if (n == 0) {
            return 0;
        }
        
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int s = n & (1 << i);
            if (s) {
                ans++;
            }
        }
        
        return ans;
    }
};


/*solution 2
* 使用位运算，通过 n & (n - 1)运算，可以每次消掉最右边的1
*/
class Solution {
public:
    int hammingWeight(uint32_t n) {
        if (n == 0) {
            return 0;
        }
        
        int ans = 0;
        while (n) {
            n = n & (n - 1);
            ++ans;
        }
        
        return ans;
    }
};

/*
 * solution 3
 * 使用查表法，罗列出每8位的值出来，然后再对32位，每次取出8位的值，通过hash求得
 */
 
 unsigned int table[256] =     
{        
         0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8        
};

int CountTable(unsigned int v)
{
    return table[v & 0xff] +
           table[(v >> 8) & 0xff] +
           table[(v >> 16) & 0xff] +
           table[(v >> 24) & 0xff] ;
}


/*
 * solution 4
 * 这个是比较不太好想的一种办法，分治法。通过把每两位切分加起来。具体分析的思路，可以参考这个博客里面的介绍
 * https://zhuanlan.zhihu.com/p/37623166
 */
 
int Count6(unsigned int v) 
{ 
    v = (v & 0x55555555) + ((v >> 1) & 0x55555555) ; 
    v = (v & 0x33333333) + ((v >> 2) & 0x33333333) ; 
    v = (v & 0x0f0f0f0f) + ((v >> 4) & 0x0f0f0f0f) ; 
    v = (v & 0x00ff00ff) + ((v >> 8) & 0x00ff00ff) ; 
    v = (v & 0x0000ffff) + ((v >> 16) & 0x0000ffff) ; 
    return v ; 
}

 
